<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pacman Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: #000;
            color: #ffff00;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            padding: 10px;
        }

        .game-header {
            text-align: center;
            margin-bottom: 20px;
        }

        h1 {
            font-size: 3rem;
            margin-bottom: 15px;
            text-shadow: 0 0 20px #ffff00;
            letter-spacing: 3px;
        }

        .game-info {
            display: flex;
            gap: 30px;
            margin-bottom: 15px;
            flex-wrap: wrap;
            justify-content: center;
            font-size: 1.2rem;
            font-weight: bold;
        }

        .info-item {
            background: rgba(255,255,0,0.1);
            padding: 8px 16px;
            border: 2px solid #ffff00;
            border-radius: 5px;
        }

        .lives {
            display: flex;
            gap: 5px;
            align-items: center;
        }

        .life {
            width: 20px;
            height: 20px;
            background: #ffff00;
            border-radius: 50%;
            position: relative;
        }

        .life::before {
            content: '';
            position: absolute;
            top: 50%;
            right: 2px;
            width: 0;
            height: 0;
            border-top: 6px solid transparent;
            border-bottom: 6px solid transparent;
            border-left: 8px solid #000;
            transform: translateY(-50%);
        }

        .game-container {
            position: relative;
            margin-bottom: 20px;
        }

        #gameCanvas {
            border: 3px solid #0000ff;
            background: #000;
            box-shadow: 0 0 30px rgba(0,0,255,0.5);
        }

        .controls {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }

        button {
            padding: 12px 24px;
            font-size: 1rem;
            font-weight: bold;
            border: 2px solid #ffff00;
            background: transparent;
            color: #ffff00;
            cursor: pointer;
            transition: all 0.3s ease;
            font-family: 'Courier New', monospace;
            text-transform: uppercase;
        }

        button:hover {
            background: #ffff00;
            color: #000;
            box-shadow: 0 0 20px rgba(255,255,0,0.5);
        }

        button:active {
            transform: scale(0.95);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .mobile-controls {
            display: none;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-top: 15px;
            max-width: 200px;
        }

        .mobile-controls button {
            width: 50px;
            height: 50px;
            font-size: 1.5rem;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .mobile-controls .empty {
            visibility: hidden;
        }

        .start-screen, .game-over-screen, .level-complete-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.95);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .screen-content {
            text-align: center;
            border: 3px solid #ffff00;
            padding: 40px;
            background: #000;
            box-shadow: 0 0 50px rgba(255,255,0,0.3);
            max-width: 500px;
            margin: 20px;
        }

        .screen-content h2 {
            font-size: 2.5rem;
            margin-bottom: 20px;
            text-shadow: 0 0 20px #ffff00;
        }

        .screen-content p {
            font-size: 1.2rem;
            margin-bottom: 15px;
            line-height: 1.5;
        }

        .ghost-intro {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            margin: 20px 0;
            font-size: 0.9rem;
        }

        .ghost-info {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px;
            border: 1px solid #ffff00;
        }

        .ghost-sprite {
            width: 25px;
            height: 25px;
            border-radius: 50% 50% 0 0;
            position: relative;
        }

        .ghost-sprite.blinky { background: #ff0000; }
        .ghost-sprite.pinky { background: #ffb8ff; }
        .ghost-sprite.inky { background: #00ffff; }
        .ghost-sprite.clyde { background: #ffb852; }

        .game-over-screen, .level-complete-screen {
            display: none;
        }

        .pause-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            display: none;
            align-items: center;
            justify-content: center;
            font-size: 3rem;
            color: #ffff00;
            text-shadow: 0 0 20px #ffff00;
        }

        .instructions {
            max-width: 900px;
            margin-top: 20px;
            padding: 20px;
            border: 1px solid #ffff00;
            background: rgba(255,255,0,0.05);
            font-size: 0.9rem;
            line-height: 1.6;
        }

        .instructions h3 {
            margin-bottom: 10px;
            font-size: 1.1rem;
            color: #ffff00;
        }

        .instructions-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-top: 15px;
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 2rem;
                letter-spacing: 1px;
            }
            
            .game-info {
                gap: 15px;
                font-size: 1rem;
            }
            
            #gameCanvas {
                width: 100%;
                max-width: 400px;
                height: auto;
            }
            
            .mobile-controls {
                display: grid;
            }
            
            .ghost-intro {
                grid-template-columns: 1fr;
            }
        }

        @media (max-width: 480px) {
            .screen-content {
                padding: 20px;
                margin: 10px;
            }
            
            .instructions-grid {
                grid-template-columns: 1fr;
            }
        }

        .power-mode {
            animation: powerPulse 0.5s ease-in-out infinite alternate;
        }

        @keyframes powerPulse {
            from { box-shadow: 0 0 30px rgba(0,0,255,0.5); }
            to { box-shadow: 0 0 50px rgba(255,255,0,0.8); }
        }

        .score-popup {
            position: absolute;
            font-size: 1.2rem;
            font-weight: bold;
            color: #ffff00;
            pointer-events: none;
            z-index: 100;
            animation: scoreFloat 1s ease-out forwards;
        }

        @keyframes scoreFloat {
            0% { opacity: 1; transform: translateY(0); }
            100% { opacity: 0; transform: translateY(-30px); }
        }
    </style>
</head>
<body>
    <div class="game-header">
        <h1>PAC-MAN</h1>
        
        <div class="game-info">
            <div class="info-item">
                SCORE: <span id="scoreDisplay">0</span>
            </div>
            <div class="info-item">
                HIGH: <span id="highScoreDisplay">0</span>
            </div>
            <div class="info-item">
                LEVEL: <span id="levelDisplay">1</span>
            </div>
            <div class="info-item">
                LIVES: <div class="lives" id="livesDisplay"></div>
            </div>
        </div>
    </div>

    <div class="game-container">
        <canvas id="gameCanvas" width="475" height="525"></canvas>
        
        <div class="pause-overlay" id="pauseOverlay">
            PAUSED
        </div>
        
        <div class="mobile-controls">
            <div class="empty"></div>
            <button id="upBtn">↑</button>
            <div class="empty"></div>
            <button id="leftBtn">←</button>
            <button id="downBtn">↓</button>
            <button id="rightBtn">→</button>
        </div>
    </div>

    <div class="controls">
        <button onclick="startGame()" id="startBtn">INICIAR</button>
        <button onclick="togglePause()" id="pauseBtn" disabled>PAUSA</button>
        <button onclick="resetGame()">REINICIAR</button>
    </div>

    <div class="start-screen" id="startScreen">
        <div class="screen-content">
            <h2>PAC-MAN</h2>
            <p>Come todos los puntos mientras evitas a los fantasmas</p>
            
            <div class="ghost-intro">
                <div class="ghost-info">
                    <div class="ghost-sprite blinky"></div>
                    <div>
                        <strong>BLINKY</strong><br>
                        "Shadow" - Te persigue
                    </div>
                </div>
                <div class="ghost-info">
                    <div class="ghost-sprite pinky"></div>
                    <div>
                        <strong>PINKY</strong><br>
                        "Speedy" - Te embosca
                    </div>
                </div>
                <div class="ghost-info">
                    <div class="ghost-sprite inky"></div>
                    <div>
                        <strong>INKY</strong><br>
                        "Bashful" - Impredecible
                    </div>
                </div>
                <div class="ghost-info">
                    <div class="ghost-sprite clyde"></div>
                    <div>
                        <strong>CLYDE</strong><br>
                        "Pokey" - Tímido
                    </div>
                </div>
            </div>
            
            <p>Usa los POWER PELLETS para comer fantasmas</p>
            <button onclick="startGame()">COMENZAR JUEGO</button>
        </div>
    </div>

    <div class="game-over-screen" id="gameOverScreen">
        <div class="screen-content">
            <h2>GAME OVER</h2>
            <p>Puntuación Final: <span id="finalScore">0</span></p>
            <p>Nivel Alcanzado: <span id="finalLevel">1</span></p>
            <p id="newRecordText" style="display: none; color: #ffff00;">
                ¡NUEVO RECORD!
            </p>
            <button onclick="playAgain()">JUGAR DE NUEVO</button>
        </div>
    </div>

    <div class="level-complete-screen" id="levelCompleteScreen">
        <div class="screen-content">
            <h2>NIVEL COMPLETADO</h2>
            <p>¡Excelente trabajo!</p>
            <p>Bonus: <span id="levelBonus">0</span> puntos</p>
            <button onclick="nextLevel()">SIGUIENTE NIVEL</button>
        </div>
    </div>

    <div class="instructions">
        <div class="instructions-grid">
            <div>
                <h3>🎯 OBJETIVO</h3>
                <p>Come todos los puntos del laberinto mientras evitas a los fantasmas. Usa power pellets para volverte invencible temporalmente.</p>
            </div>
            <div>
                <h3>🎮 CONTROLES</h3>
                <p><strong>Desktop:</strong> Flechas o WASD<br>
                <strong>Mobile:</strong> Botones o gestos<br>
                <strong>Espacio:</strong> Pausar<br>
                <strong>Enter:</strong> Reiniciar</p>
            </div>
            <div>
                <h3>🏆 PUNTUACIÓN</h3>
                <p>Punto: 10 pts<br>
                Power pellet: 50 pts<br>
                Fantasma: 200-1600 pts<br>
                Fruta: 100-5000 pts<br>
                Vida extra: 10,000 pts</p>
            </div>
            <div>
                <h3>💡 CONSEJOS</h3>
                <p>Planifica tu ruta, usa las esquinas, observa patrones de fantasmas, y conserva power pellets para emergencias.</p>
            </div>
        </div>
    </div>

    <script>
        // Game constants
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        const CELL_SIZE = 25;
        const MAZE_WIDTH = 19;
        const MAZE_HEIGHT = 21;
        
        // Simplified maze (1=wall, 0=empty, 2=dot, 3=power pellet, 4=ghost door)
        const MAZE = [
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            [1,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,1],
            [1,3,1,1,1,2,1,1,1,1,1,1,1,2,1,1,1,3,1],
            [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
            [1,2,1,1,1,2,1,2,1,1,1,2,1,2,1,1,1,2,1],
            [1,2,2,2,2,2,1,2,2,1,2,2,1,2,2,2,2,2,1],
            [1,1,1,1,1,2,1,1,0,1,0,1,1,2,1,1,1,1,1],
            [0,0,0,0,1,2,1,0,0,0,0,0,1,2,1,0,0,0,0],
            [1,1,1,1,1,2,1,0,1,4,1,0,1,2,1,1,1,1,1],
            [0,0,0,0,0,2,0,0,1,0,1,0,0,2,0,0,0,0,0],
            [1,1,1,1,1,2,1,0,1,1,1,0,1,2,1,1,1,1,1],
            [0,0,0,0,1,2,1,0,0,0,0,0,1,2,1,0,0,0,0],
            [1,1,1,1,1,2,1,1,0,1,0,1,1,2,1,1,1,1,1],
            [1,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,1],
            [1,2,1,1,1,2,1,1,1,1,1,1,1,2,1,1,1,2,1],
            [1,3,2,1,2,2,2,2,2,2,2,2,2,2,2,1,2,3,1],
            [1,1,2,1,2,1,2,1,1,1,1,1,2,1,2,1,2,1,1],
            [1,2,2,2,2,1,2,2,1,1,1,2,2,1,2,2,2,2,1],
            [1,2,1,1,1,1,1,2,2,1,2,2,1,1,1,1,1,2,1],
            [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
        ];

        // Game variables
        let gameState = 'start'; // start, playing, paused, gameOver, levelComplete
        let score = 0;
        let highScore = localStorage.getItem('pacmanHighScore') || 0;
        let level = 1;
        let lives = 3;
        let dotsRemaining = 0;
        let powerMode = false;
        let powerModeTimer = 0;
        let gameSpeed = 150;
        let animationId = null;

        // Game objects
        const pacman = {
            x: 9,
            y: 15,
            direction: 'right',
            nextDirection: 'right',
            mouthOpen: true,
            animationCounter: 0
        };

        const ghosts = [
            { x: 9, y: 9, color: '#ff0000', name: 'blinky', direction: 'up', mode: 'scatter', target: {x: 18, y: 0} },
            { x: 9, y: 9, color: '#ffb8ff', name: 'pinky', direction: 'down', mode: 'scatter', target: {x: 0, y: 0} },
            { x: 8, y: 9, color: '#00ffff', name: 'inky', direction: 'up', mode: 'scatter', target: {x: 18, y: 20} },
            { x: 10, y: 9, color: '#ffb852', name: 'clyde', direction: 'up', mode: 'scatter', target: {x: 0, y: 20} }
        ];

        let maze = JSON.parse(JSON.stringify(MAZE)); // Deep copy

        // Initialize
        document.getElementById('highScoreDisplay').textContent = highScore;
        updateDisplay();
        countDots();
        setupControls();
        gameLoop();

        function setupControls() {
            // Keyboard controls
            document.addEventListener('keydown', handleKeyPress);
            
            // Mobile controls
            document.getElementById('upBtn').addEventListener('click', () => pacman.nextDirection = 'up');
            document.getElementById('downBtn').addEventListener('click', () => pacman.nextDirection = 'down');
            document.getElementById('leftBtn').addEventListener('click', () => pacman.nextDirection = 'left');
            document.getElementById('rightBtn').addEventListener('click', () => pacman.nextDirection = 'right');
            
            // Touch gestures
            let touchStartX = 0;
            let touchStartY = 0;
            
            canvas.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const touch = e.touches[0];
                touchStartX = touch.clientX;
                touchStartY = touch.clientY;
            });
            
            canvas.addEventListener('touchend', (e) => {
                e.preventDefault();
                if (!touchStartX || !touchStartY) return;
                
                const touch = e.changedTouches[0];
                const deltaX = touch.clientX - touchStartX;
                const deltaY = touch.clientY - touchStartY;
                
                const minSwipeDistance = 30;
                
                if (Math.abs(deltaX) > Math.abs(deltaY)) {
                    if (Math.abs(deltaX) > minSwipeDistance) {
                        pacman.nextDirection = deltaX > 0 ? 'right' : 'left';
                    }
                } else {
                    if (Math.abs(deltaY) > minSwipeDistance) {
                        pacman.nextDirection = deltaY > 0 ? 'down' : 'up';
                    }
                }
                
                touchStartX = 0;
                touchStartY = 0;
            });
        }

        function handleKeyPress(event) {
            if (gameState === 'gameOver' && event.code === 'Enter') {
                playAgain();
                return;
            }
            
            if (event.code === 'Space') {
                event.preventDefault();
                togglePause();
                return;
            }
            
            if (gameState !== 'playing') return;
            
            switch(event.code) {
                case 'ArrowUp':
                case 'KeyW':
                    event.preventDefault();
                    pacman.nextDirection = 'up';
                    break;
                case 'ArrowDown':
                case 'KeyS':
                    event.preventDefault();
                    pacman.nextDirection = 'down';
                    break;
                case 'ArrowLeft':
                case 'KeyA':
                    event.preventDefault();
                    pacman.nextDirection = 'left';
                    break;
                case 'ArrowRight':
                case 'KeyD':
                    event.preventDefault();
                    pacman.nextDirection = 'right';
                    break;
            }
        }

        function startGame() {
            gameState = 'playing';
            score = 0;
            level = 1;
            lives = 3;
            powerMode = false;
            powerModeTimer = 0;
            
            resetLevel();
            
            document.getElementById('startScreen').style.display = 'none';
            document.getElementById('gameOverScreen').style.display = 'none';
            document.getElementById('levelCompleteScreen').style.display = 'none';
            document.getElementById('startBtn').disabled = true;
            document.getElementById('pauseBtn').disabled = false;
            
            updateDisplay();
            trackEvent('game_start');
        }

        function resetLevel() {
            maze = JSON.parse(JSON.stringify(MAZE));
            pacman.x = 9;
            pacman.y = 15;
            pacman.direction = 'right';
            pacman.nextDirection = 'right';
            
            // Reset ghosts
            ghosts[0].x = 9; ghosts[0].y = 9;
            ghosts[1].x = 9; ghosts[1].y = 9;
            ghosts[2].x = 8; ghosts[2].y = 9;
            ghosts[3].x = 10; ghosts[3].y = 9;
            
            ghosts.forEach(ghost => {
                ghost.mode = 'scatter';
                ghost.direction = 'up';
            });
            
            countDots();
            powerMode = false;
            powerModeTimer = 0;
        }

        function countDots() {
            dotsRemaining = 0;
            for (let y = 0; y < MAZE_HEIGHT; y++) {
                for (let x = 0; x < MAZE_WIDTH; x++) {
                    if (maze[y][x] === 2 || maze[y][x] === 3) {
                        dotsRemaining++;
                    }
                }
            }
        }

        function togglePause() {
            if (gameState === 'playing') {
                gameState = 'paused';
                document.getElementById('pauseOverlay').style.display = 'flex';
                document.getElementById('pauseBtn').textContent = 'REANUDAR';
            } else if (gameState === 'paused') {
                gameState = 'playing';
                document.getElementById('pauseOverlay').style.display = 'none';
                document.getElementById('pauseBtn').textContent = 'PAUSA';
            }
        }

        function resetGame() {
            gameState = 'start';
            document.getElementById('startScreen').style.display = 'flex';
            document.getElementById('startBtn').disabled = false;
            document.getElementById('pauseBtn').disabled = true;
            document.getElementById('pauseBtn').textContent = 'PAUSA';
            document.getElementById('pauseOverlay').style.display = 'none';
        }

        function gameLoop() {
            if (gameState === 'playing') {
                update();
            }
            draw();
            
            setTimeout(() => {
                gameLoop();
            }, gameSpeed);
        }

        function update() {
            // Update power mode timer
            if (powerMode) {
                powerModeTimer--;
                if (powerModeTimer <= 0) {
                    powerMode = false;
                    canvas.classList.remove('power-mode');
                    ghosts.forEach(ghost => {
                        if (ghost.mode === 'frightened') {
                            ghost.mode = 'chase';
                        }
                    });
                }
            }
            
            // Update Pacman
            updatePacman();
            
            // Update ghosts
            ghosts.forEach(updateGhost);
            
            // Check collisions
            checkCollisions();
            
            // Check level complete
            if (dotsRemaining === 0) {
                levelComplete();
            }
        }

        function updatePacman() {
            // Try to change direction
            if (canMove(pacman.x, pacman.y, pacman.nextDirection)) {
                pacman.direction = pacman.nextDirection;
            }
            
            // Move Pacman
            if (canMove(pacman.x, pacman.y, pacman.direction)) {
                const newPos = getNewPosition(pacman.x, pacman.y, pacman.direction);
                pacman.x = newPos.x;
                pacman.y = newPos.y;
                
                // Handle tunnel
                if (pacman.x < 0) pacman.x = MAZE_WIDTH - 1;
                if (pacman.x >= MAZE_WIDTH) pacman.x = 0;
                
                // Eat dots
                if (maze[pacman.y][pacman.x] === 2) {
                    maze[pacman.y][pacman.x] = 0;
                    score += 10;
                    dotsRemaining--;
                    updateDisplay();
                } else if (maze[pacman.y][pacman.x] === 3) {
                    maze[pacman.y][pacman.x] = 0;
                    score += 50;
                    dotsRemaining--;
                    activatePowerMode();
                    updateDisplay();
                }
            }
            
            // Update mouth animation
            pacman.animationCounter++;
            if (pacman.animationCounter >= 8) {
                pacman.mouthOpen = !pacman.mouthOpen;
                pacman.animationCounter = 0;
            }
        }

        function updateGhost(ghost) {
            // Simple AI - move towards target
            const directions = ['up', 'down', 'left', 'right'];
            let bestDirection = ghost.direction;
            let bestDistance = Infinity;
            
            // Set target based on mode
            if (ghost.mode === 'chase') {
                ghost.target = getChaseTarget(ghost);
            } else if (ghost.mode === 'frightened') {
                // Random movement when frightened
                const validDirections = directions.filter(dir => 
                    canMove(ghost.x, ghost.y, dir) && dir !== getOppositeDirection(ghost.direction)
                );
                if (validDirections.length > 0) {
                    ghost.direction = validDirections[Math.floor(Math.random() * validDirections.length)];
                }
            }
            
            if (ghost.mode !== 'frightened') {
                // Find best direction towards target
                for (const direction of directions) {
                    if (canMove(ghost.x, ghost.y, direction) && direction !== getOppositeDirection(ghost.direction)) {
                        const newPos = getNewPosition(ghost.x, ghost.y, direction);
                        const distance = Math.sqrt(
                            Math.pow(newPos.x - ghost.target.x, 2) + 
                            Math.pow(newPos.y - ghost.target.y, 2)
                        );
                        
                        if (distance < bestDistance) {
                            bestDistance = distance;
                            bestDirection = direction;
                        }
                    }
                }
                ghost.direction = bestDirection;
            }
            
            // Move ghost
            if (canMove(ghost.x, ghost.y, ghost.direction)) {
                const newPos = getNewPosition(ghost.x, ghost.y, ghost.direction);
                ghost.x = newPos.x;
                ghost.y = newPos.y;
                
                // Handle tunnel
                if (ghost.x < 0) ghost.x = MAZE_WIDTH - 1;
                if (ghost.x >= MAZE_WIDTH) ghost.x = 0;
            }
        }

        function getChaseTarget(ghost) {
            switch(ghost.name) {
                case 'blinky':
                    return { x: pacman.x, y: pacman.y };
                case 'pinky':
                    const pinkyTarget = getNewPosition(pacman.x, pacman.y, pacman.direction);
                    return getNewPosition(pinkyTarget.x, pinkyTarget.y, pacman.direction);
                case 'inky':
                    return { x: pacman.x, y: pacman.y }; // Simplified
                case 'clyde':
                    const distance = Math.sqrt(Math.pow(ghost.x - pacman.x, 2) + Math.pow(ghost.y - pacman.y, 2));
                    return distance > 8 ? { x: pacman.x, y: pacman.y } : ghost.target;
                default:
                    return { x: pacman.x, y: pacman.y };
            }
        }

        function canMove(x, y, direction) {
            const newPos = getNewPosition(x, y, direction);
            
            // Handle tunnel
            if (newPos.x < 0 || newPos.x >= MAZE_WIDTH) return true;
            if (newPos.y < 0 || newPos.y >= MAZE_HEIGHT) return false;
            
            return maze[newPos.y][newPos.x] !== 1;
        }

        function getNewPosition(x, y, direction) {
            switch(direction) {
                case 'up': return { x, y: y - 1 };
                case 'down': return { x, y: y + 1 };
                case 'left': return { x: x - 1, y };
                case 'right': return { x: x + 1, y };
                default: return { x, y };
            }
        }

        function getOppositeDirection(direction) {
            const opposites = { up: 'down', down: 'up', left: 'right', right: 'left' };
            return opposites[direction];
        }

        function activatePowerMode() {
            powerMode = true;
            powerModeTimer = 300; // 6 seconds at 50fps
            canvas.classList.add('power-mode');
            
            ghosts.forEach(ghost => {
                ghost.mode = 'frightened';
            });
            
            trackEvent('power_mode_activated');
        }

        function checkCollisions() {
            ghosts.forEach((ghost, index) => {
                if (ghost.x === pacman.x && ghost.y === pacman.y) {
                    if (powerMode && ghost.mode === 'frightened') {
                        // Eat ghost
                        const points = [200, 400, 800, 1600][Math.min(3, index)];
                        score += points;
                        showScorePopup(ghost.x * CELL_SIZE, ghost.y * CELL_SIZE, points);
                        
                        // Reset ghost to home
                        ghost.x = 9;
                        ghost.y = 9;
                        ghost.mode = 'scatter';
                        
                        updateDisplay();
                        trackEvent('ghost_eaten', { ghost: ghost.name, points });
                    } else if (ghost.mode !== 'frightened') {
                        // Pacman dies
                        lives--;
                        updateDisplay();
                        
                        if (lives <= 0) {
                            gameOver();
                        } else {
                            // Reset positions
                            pacman.x = 9;
                            pacman.y = 15;
                            ghosts.forEach((g, i) => {
                                g.x = [9, 9, 8, 10][i];
                                g.y = 9;
                                g.mode = 'scatter';
                            });
                        }
                        
                        trackEvent('pacman_died', { livesRemaining: lives });
                    }
                }
            });
        }

        function showScorePopup(x, y, points) {
            const popup = document.createElement('div');
            popup.className = 'score-popup';
            popup.textContent = `+${points}`;
            popup.style.left = x + 'px';
            popup.style.top = y + 'px';
            
            document.querySelector('.game-container').appendChild(popup);
            
            setTimeout(() => {
                if (popup.parentNode) {
                    popup.parentNode.removeChild(popup);
                }
            }, 1000);
        }

        function levelComplete() {
            gameState = 'levelComplete';
            level++;
            
            const bonus = level * 1000;
            score += bonus;
            
            document.getElementById('levelBonus').textContent = bonus;
            document.getElementById('levelCompleteScreen').style.display = 'flex';
            
            updateDisplay();
            trackEvent('level_complete', { level: level - 1, bonus });
        }

        function nextLevel() {
            document.getElementById('levelCompleteScreen').style.display = 'none';
            gameState = 'playing';
            
            resetLevel();
            
            // Increase difficulty
            gameSpeed = Math.max(100, gameSpeed - 10);
        }

        function gameOver() {
            gameState = 'gameOver';
            
            // Check for new high score
            const isNewRecord = score > highScore;
            if (isNewRecord) {
                highScore = score;
                localStorage.setItem('pacmanHighScore', highScore);
                document.getElementById('highScoreDisplay').textContent = highScore;
                document.getElementById('newRecordText').style.display = 'block';
            } else {
                document.getElementById('newRecordText').style.display = 'none';
            }
            
            document.getElementById('finalScore').textContent = score;
            document.getElementById('finalLevel').textContent = level;
            document.getElementById('gameOverScreen').style.display = 'flex';
            document.getElementById('pauseBtn').disabled = true;
            
            trackEvent('game_over', { score, level, newRecord: isNewRecord });
        }

        function playAgain() {
            document.getElementById('gameOverScreen').style.display = 'none';
            startGame();
        }

        function draw() {
            // Clear canvas
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw maze
            for (let y = 0; y < MAZE_HEIGHT; y++) {
                for (let x = 0; x < MAZE_WIDTH; x++) {
                    const cell = maze[y][x];
                    const pixelX = x * CELL_SIZE;
                    const pixelY = y * CELL_SIZE;
                    
                    if (cell === 1) {
                        // Wall
                        ctx.fillStyle = '#0000ff';
                        ctx.fillRect(pixelX, pixelY, CELL_SIZE, CELL_SIZE);
                    } else if (cell === 2) {
                        // Dot
                        ctx.fillStyle = '#ffff00';
                        ctx.beginPath();
                        ctx.arc(pixelX + CELL_SIZE/2, pixelY + CELL_SIZE/2, 2, 0, Math.PI * 2);
                        ctx.fill();
                    } else if (cell === 3) {
                        // Power pellet
                        ctx.fillStyle = '#ffff00';
                        ctx.beginPath();
                        ctx.arc(pixelX + CELL_SIZE/2, pixelY + CELL_SIZE/2, 6, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            }
            
            // Draw Pacman
            drawPacman();
            
            // Draw ghosts
            ghosts.forEach(drawGhost);
        }

        function drawPacman() {
            const pixelX = pacman.x * CELL_SIZE + CELL_SIZE/2;
            const pixelY = pacman.y * CELL_SIZE + CELL_SIZE/2;
            
            ctx.fillStyle = '#ffff00';
            ctx.beginPath();
            
            if (pacman.mouthOpen) {
                // Draw Pacman with mouth open
                let startAngle = 0;
                let endAngle = Math.PI * 2;
                
                switch(pacman.direction) {
                    case 'right':
                        startAngle = Math.PI * 0.2;
                        endAngle = Math.PI * 1.8;
                        break;
                    case 'left':
                        startAngle = Math.PI * 1.2;
                        endAngle = Math.PI * 0.8;
                        break;
                    case 'up':
                        startAngle = Math.PI * 1.7;
                        endAngle = Math.PI * 1.3;
                        break;
                    case 'down':
                        startAngle = Math.PI * 0.7;
                        endAngle = Math.PI * 0.3;
                        break;
                }
                
                ctx.arc(pixelX, pixelY, CELL_SIZE/2 - 2, startAngle, endAngle);
                ctx.lineTo(pixelX, pixelY);
            } else {
                // Draw closed circle
                ctx.arc(pixelX, pixelY, CELL_SIZE/2 - 2, 0, Math.PI * 2);
            }
            
            ctx.fill();
        }

        function drawGhost(ghost) {
            const pixelX = ghost.x * CELL_SIZE + CELL_SIZE/2;
            const pixelY = ghost.y * CELL_SIZE + CELL_SIZE/2;
            
            if (powerMode && ghost.mode === 'frightened') {
                ctx.fillStyle = powerModeTimer % 60 < 30 ? '#0000ff' : '#ffffff';
            } else {
                ctx.fillStyle = ghost.color;
            }
            
            // Draw ghost body
            ctx.beginPath();
            ctx.arc(pixelX, pixelY - 3, CELL_SIZE/2 - 2, Math.PI, 0);
            ctx.rect(pixelX - CELL_SIZE/2 + 2, pixelY - 3, CELL_SIZE - 4, CELL_SIZE/2);
            
            // Draw ghost bottom (wavy)
            ctx.moveTo(pixelX - CELL_SIZE/2 + 2, pixelY + CELL_SIZE/2 - 3);
            ctx.lineTo(pixelX - CELL_SIZE/4, pixelY + CELL_SIZE/2 - 8);
            ctx.lineTo(pixelX, pixelY + CELL_SIZE/2 - 3);
            ctx.lineTo(pixelX + CELL_SIZE/4, pixelY + CELL_SIZE/2 - 8);
            ctx.lineTo(pixelX + CELL_SIZE/2 - 2, pixelY + CELL_SIZE/2 - 3);
            
            ctx.fill();
            
            // Draw eyes
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(pixelX - 5, pixelY - 5, 3, 0, Math.PI * 2);
            ctx.arc(pixelX + 5, pixelY - 5, 3, 0, Math.PI * 2);
            ctx.fill();
            
            if (!(powerMode && ghost.mode === 'frightened')) {
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(pixelX - 5, pixelY - 5, 1, 0, Math.PI * 2);
                ctx.arc(pixelX + 5, pixelY - 5, 1, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function updateDisplay() {
            document.getElementById('scoreDisplay').textContent = score;
            document.getElementById('levelDisplay').textContent = level;
            
            // Update lives display
            const livesDisplay = document.getElementById('livesDisplay');
            livesDisplay.innerHTML = '';
            for (let i = 0; i < lives; i++) {
                const life = document.createElement('div');
                life.className = 'life';
                livesDisplay.appendChild(life);
            }
            
            // Check for extra life
            if (score > 0 && score % 10000 === 0) {
                lives++;
                updateDisplay();
                trackEvent('extra_life', { score });
            }
        }

        function trackEvent(eventType, data = {}) {
            const event = {
                game: 'pacman',
                type: eventType,
                timestamp: new Date().toISOString(),
                data: data
            };
            
            fetch('/analytics/event', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(event)
            }).catch(err => {
                const events = JSON.parse(localStorage.getItem('pacmanEvents') || '[]');
                events.push(event);
                localStorage.setItem('pacmanEvents', JSON.stringify(events));
            });
        }
    </script>
</body>
</html>